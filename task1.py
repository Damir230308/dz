"""
Задание 1.
Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива
Сделайте замеры времени выполнения кода с помощью модуля timeit
Попробуйте оптимизировать код, чтобы снизить время выполнения
Проведите повторные замеры
ОБЯЗАТЕЛЬНО! Добавьте аналитику: что вы сделали и какой это принесло эффект
"""
import timeit

def func(nums):
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
        return new_arr
func([1, 4, 6])
print(timeit.timeit("func", "from __main__ import func", number=100000))

def func2(nums):
    return [i for n, i in enumerate(nums) if not n % 2]
func2([1, 4, 6])
print(timeit.timeit("func2", "from __main__ import func2", number=100000))

"""
Первый вариант: попробовать создать список за пределами ф-ции

0.0008827999999999996 - func

0.0008819999999999991 - func2

Итог: ненамного конечно, но всё же на какое-то время получилось сократить, если учесть тот факт что в timeit плавают
значения


Второй способ:

Наш старый добрый list comprehensions

0.0008663000000000004 - func
0.0008660000000000004 - func2

Итог:Получилось немного сократить время, но не забываем о том что значения в timeit'е плавают.
Вывод: вторая ф-ция быстрее чем первая, но с учётом плавания значений в timeit

P.s. Если знаете что с этим делать напишите комментарий под работой
"""
